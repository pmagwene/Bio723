

* Medium scale data processing
Quite a lot of what working biologists do (or could do) with computers
is 'medium scale computing.' I don't know if there's a technical
definition of this, but to me it means that you have too much data for
dealing with in excel, but too little to justify setting up a database
for sophisticated queries. Biological data often comes in batches
(different experimental days) and with lots of covariates (geotype,
environment, person who collected the data). For me the challenge was
learning to quickly get all that data along with it's covariates into
R in a way that was flexible and reusable. That is, my experiments
change all the time, so things can't be too hard-coded, but things
also stay the same and I don't want to have to copy and paste too much.

* A review of lists
** What is a list?
When I first started using R, I never bothered much with lists. If I
had three different datasets, they would all be stored as three
different data frames. The problem with this is that you need to
remember what data.frames go together, what their names are, and
what their relationship to each other is. This is where lists come
in. Rather than storing everything as a separate variable, a list has
slots to put conceptually related objects together.

** Making a list by hand 


#+begin_src R :results output
  baseFile = "http://people.duke.edu/~csm29/morphology_data"
   
  dataTypes = list(
      actin = "_actin_biological.xls",
      dapi = "_dapi_biological.xls",
      conA = "_conA_biological.xls"
      )
  
  samples <- list("2a1_HAHD" = "2a1_HAHD",
                  "2a1_HALD" = "2a1_HALD",
                  "2a1_LALD" = "2a1_LALD",
                  "2a1_LAHD" = "2a1_LAHD",
                  "2b1_HAHD" = "2b1_HAHD",
                  "2b1_HALD" = "2b1_HALD",
                  "2b1_LALD" = "2b1_LALD",
                  "2b1_LAHD" = "2b1_LAHD"
                  )
  
  defs <- read.csv("http://people.duke.edu/~csm29/morphology_data/definitions_without_stage.csv", as.is=T)
  rownames(defs) <- defs$ID
#+end_src

#+results:


** [[ vs [

There are two functions to index list items: '[' and '[['. It might
seem funny to have these symbols called 'functions', but that's
exactly what they are stored as in R. If you just type in '[' to the
command line, you'll get an error, but if you put the brackets in the
funny backwards quote marks, this tells R that you want to look at
what the function means rather than calling it:

#+begin_src R :results output
  `[`
#+end_src

#+results:
: .Primitive("[")

In fact, you can use the backwards quotes to see what the function
does. It's first argument is a list, it's second argument can be
either an integer or a string. What it does is return the list element
that has either the name of the string or the index of the
integer. Importantly, it returns the results as a list.

#+begin_src R :results output
  `[`(samples, 1)
  `[`(samples, "2a1_HAHD")
#+end_src

#+results:
: $`2a1_HAHD`
: [1] "2a1_HAHD"
: $`2a1_HAHD`
: [1] "2a1_HAHD"

The usual way you use this function is more familiar:

#+begin_src R :results output
samples[1]
samples["2a1_HAHD"]
#+end_src

#+results:
: $`2a1_HAHD`
: [1] "2a1_HAHD"
: $`2a1_HAHD`
: [1] "2a1_HAHD"

You can use '[' to return more than one item in a list:

#+begin_src R :results output
samples[1:3]
print("")
samples[c("2a1_HAHD","2a1_HALD", "2a1_LALD")]
#+end_src

#+results:
#+begin_example
$`2a1_HAHD`
[1] "2a1_HAHD"

$`2a1_HALD`
[1] "2a1_HALD"

$`2a1_LALD`
[1] "2a1_LALD"
[1] ""
$`2a1_HAHD`
[1] "2a1_HAHD"

$`2a1_HALD`
[1] "2a1_HALD"

$`2a1_LALD`
[1] "2a1_LALD"
#+end_example

The second way to index lists is similar, but rather than returning a
list, it returns the value of the list item

#+begin_src R :results output
samples[[1]]
samples[["2a1_HAHD"]]
#+end_src

#+results:
: [1] "2a1_HAHD"
: [1] "2a1_HAHD"

You can't return more than one item like this:

#+begin_src R :results output
samples[[1:3]]
#+end_src

#+results:
: Error in samples[[1:3]] : recursive indexing failed at level 2


* lapply

The simplest function to work with lists is lapply. The thing to
remember about 'apply' functions is that they call a function that you
determine with each successive list item as the first argument of the
function. The clutch thing about 'apply' functions is that they
remember the names of the list items:

#+begin_src R :results output
  lapply( samples[1:4], function(x) x) 
#+end_src

#+results:
#+begin_example
$`2a1_HAHD`
[1] "2a1_HAHD"

$`2a1_HALD`
[1] "2a1_HALD"

$`2a1_LALD`
[1] "2a1_LALD"

$`2a1_LALD`
[1] "2a1_LALD"
#+end_example


#+begin_src R :results output
  lapply( samples[1:4], function(x) gsub("L", "X", x)) 
#+end_src

#+results:
#+begin_example
$`2a1_HAHD`
[1] "2a1_HAHD"

$`2a1_HALD`
[1] "2a1_HAXD"

$`2a1_LALD`
[1] "2a1_XAXD"

$`2a1_LALD`
[1] "2a1_XAXD"
#+end_example

#+begin_src R :results output
  lapply( samples[1:2], strsplit, "_")
#+end_src

#+results:
: $`2a1_HAHD`
: $`2a1_HAHD`[[1]]
: [1] "2a1"  "HAHD"
: 
: 
: $`2a1_HALD`
: $`2a1_HALD`[[1]]
: [1] "2a1"  "HALD"

#+begin_src R :results output
  str(lapply( samples[1:2], strsplit, "_"))
#+end_src

#+results:
: List of 2
:  $ 2a1_HAHD:List of 1
:   ..$ : chr [1:2] "2a1" "HAHD"
:  $ 2a1_HALD:List of 1
:   ..$ : chr [1:2] "2a1" "HALD"

#+begin_src R :results output
  lapply( samples[1:2], function(x){
      out <- strsplit(x, "_")
      out[[1]]
  })
#+end_src

#+results:
:  $`2a1_HAHD`
: [1] "2a1"  "HAHD"
: 
: $`2a1_HALD`
: [1] "2a1"  "HALD"

* sapply
#+begin_src R :results output
  sapply( samples[1:2], function(x){
      out <- strsplit(x, "_")
      out[[1]]
  })
#+end_src

#+results:
:      2a1_HAHD 2a1_HALD
: [1,] "2a1"    "2a1"   
: [2,] "HAHD"   "HALD"

#+begin_src R :results output
  sapply( samples[1:2], function(x){
      out <- strsplit(x, "_")
      out = out[[1]]
      names(out) = c("strain", "media")
      out
  })
#+end_src

#+results:
:        2a1_HAHD 2a1_HALD
: strain "2a1"    "2a1"   
: media  "HAHD"   "HALD"

* Nested lists

#+begin_src R :results output
  makeDataPaths <- function(x, bFile, dTypes){
      dataFolder <- paste( bFile, x, x, sep = "/")
      lapply(dTypes, function(d){
          paste( dataFolder, d, sep = "")
      })
  }
  
  str(dataPaths <- lapply( samples, makeDataPaths, baseFile, dataTypes))
#+end_src

#+results:
#+begin_example

List of 8
 $ 2a1_HAHD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_conA_biological.xls"
 $ 2a1_HALD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_conA_biological.xls"
 $ 2a1_LALD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_LALD/2a1_LALD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_LALD/2a1_LALD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_LALD/2a1_LALD_conA_biological.xls"
 $ 2a1_LAHD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_LAHD/2a1_LAHD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_LAHD/2a1_LAHD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_LAHD/2a1_LAHD_conA_biological.xls"
 $ 2b1_HAHD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2b1_HAHD/2b1_HAHD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2b1_HAHD/2b1_HAHD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2b1_HAHD/2b1_HAHD_conA_biological.xls"
 $ 2b1_HALD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2b1_HALD/2b1_HALD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2b1_HALD/2b1_HALD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2b1_HALD/2b1_HALD_conA_biological.xls"
 $ 2b1_LALD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2b1_LALD/2b1_LALD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2b1_LALD/2b1_LALD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2b1_LALD/2b1_LALD_conA_biological.xls"
 $ 2b1_LAHD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2b1_LAHD/2b1_LAHD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2b1_LAHD/2b1_LAHD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2b1_LAHD/2b1_LAHD_conA_biological.xls"
#+end_example

#+begin_src R :results output
  foo = lapply( dataPaths[1:2], lapply, print)
#+end_src

#+results:
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_actin_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_dapi_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_conA_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_actin_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_dapi_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_conA_biological.xls"

* rapply


#+begin_src R :results output
  str(
    rapply( dataPaths[1:2], c, how="unlist")
      )
#+end_src

#+results:
:  Named chr [1:6] "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_actin_biological.xls" ...
:  - attr(*, "names")= chr [1:6] "2a1_HAHD.actin" "2a1_HAHD.dapi" "2a1_HAHD.conA" "2a1_HALD.actin" ...

#+begin_src R :results output
  str(
    rapply( dataPaths[1:2], c, how="list")
      )
#+end_src

#+results:
:  List of 2
:  $ 2a1_HAHD:List of 3
:   ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_actin_biological.xls"
:   ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_dapi_biological.xls"
:   ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_conA_biological.xls"
:  $ 2a1_HALD:List of 3
:   ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_actin_biological.xls"
:   ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_dapi_biological.xls"
:   ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_conA_biological.xls"

* Reading in data

#+begin_src R :results output
  morphList <- rapply( dataPaths, read.table, header = T, sep="\t", how="list")
  lapply(lapply( morphList, sapply, dim), t)
#+end_src

#+results:
#+begin_example

$`2a1_HAHD`
      [,1] [,2]
actin  114   13
dapi   114  103
conA   114   25

$`2a1_HALD`
      [,1] [,2]
actin  109   13
dapi   109  103
conA   109   25

$`2a1_LALD`
      [,1] [,2]
actin   73   13
dapi    73  103
conA    73   25

$`2a1_LAHD`
      [,1] [,2]
actin  100   13
dapi   100  103
conA   100   25

$`2b1_HAHD`
      [,1] [,2]
actin  104   13
dapi   104  103
conA   104   25

$`2b1_HALD`
      [,1] [,2]
actin   86   13
dapi    86  103
conA    86   25

$`2b1_LALD`
      [,1] [,2]
actin  105   13
dapi   105  103
conA   105   25

$`2b1_LAHD`
      [,1] [,2]
actin  147   13
dapi   147  103
conA   147   25
#+end_example

* Filtering out bad data

#+begin_src R :results output
  removeBadData <- function(x){
      out <- subset(x, Cgroup != "complex")
      out <- subset(out, Dgroup != "-")
      out <- subset(out, Agroup != "-")
      unneededColumns <- grep("\\.1|\\.2|X", colnames(out))
      out[,-unneededColumns]
      
  }
  
  morphListFiltered <- lapply( morphList, function(x){
      data.frame( x[[1]], x[[2]], x[[3]])
  })
  
  
  morphListFiltered <- lapply( morphListFiltered, removeBadData)
  
  
#+end_src

#+results:

* Melting data

#+begin_src R :results output
  library(reshape)
  
  examp <- subset(morphListFiltered[[1]],
                  select = c(image_number, cell_id, Dgroup, C101, C102, C103, C104, C115, C118)
                  )
  
  examp$phase <- NA
  examp$phase[ examp$Dgroup == "A" ] <- "G1"
  examp$phase[ examp$Dgroup == "A1" ] <- "S"
  examp$phase[ examp$Dgroup == "C" ] <- "M"
  
  examp <- subset( examp, !is.na(phase) )
  examp <- subset(examp, select = -Dgroup)
  
  head(examp)
#+end_src

#+results:
#+begin_example

  image_number cell_id C101     C102     C103     C104     C115       C118
1            1       0 1341 135.0538 45.60702 35.60899 1.280773 -1.0000000
2            1       1 2010 167.1960 58.24088 42.72002 1.363316 -1.0000000
3            1       2 1359 136.7107 47.38143 35.35534 1.340149 -1.0000000
4            1       3  879 109.4975 38.58756 28.30194 1.363424 -1.0000000
5            1       4 1526 173.1960 38.94868 32.55764 1.196299  0.4355597
6            1       5 1933 204.4092 46.17359 30.14963 1.531481  0.6779514
  phase
1    G1
2    G1
3    G1
4    G1
5     S
6     S
#+end_example


#+begin_src R :results output
  examp.m <- melt(examp, id.vars = c("image_number", "cell_id", "phase"))
  head(examp.m)
#+end_src

#+results:
: 
:   image_number cell_id phase variable value
: 1            1       0    G1     C101  1341
: 2            1       1    G1     C101  2010
: 3            1       2    G1     C101  1359
: 4            1       3    G1     C101   879
: 5            1       4     S     C101  1526
: 6            1       5     S     C101  1933

#+begin_src R :results output
  unique(examp.m$variable)
#+end_src

#+results:
: [1] C101 C102 C103 C104 C115 C118
: Levels: C101 C102 C103 C104 C115 C118

#+begin_src R :results output
  defs[as.character(unique(examp.m$variable)), c("ID","concise_description")]
#+end_src

#+results:
:        ID              concise_description
: C101 C101                  Whole cell size
: C102 C102        Whole cell outline length
: C103 C103  Long axis length in mother cell
: C104 C104 Short axis length in mother cell
: C115 C115                Mother axis ratio
: C118 C118                  Cell size ratio


#+begin_src R :results output
  examp.m2 <- melt(examp, id.vars = c("image_number", "cell_id"))
  head(examp.m2)
#+end_src

#+results:
: 
:   image_number cell_id variable value
: 1            1       0     C101  1341
: 2            1       1     C101  2010
: 3            1       2     C101  1359
: 4            1       3     C101   879
: 5            1       4     C101  1526
: 6            1       5     C101  1933


#+begin_src R :results output
  unique(examp.m2$variable)
#+end_src

#+results:
: [1] C101  C102  C103  C104  C115  C118  phase
: Levels: C101 C102 C103 C104 C115 C118 phase

Depending on the way you want to plot or analyze your data, it makes
sense to have your data in either the long or the short form. For
instance, if you wanted to look at all the variables as difference
plot facets, you would want the data in the long form:

#+begin_src R :results output graphics :file r/file73.png
  ggplot( examp.m, aes(x = value, col=phase))+
      geom_density()+
      facet_wrap(~variable, scale='free')
#+end_src

#+results:
[[file:r/file73.png]]


#+begin_src R :results output graphics :file r/file74.png
  ggplot(examp, aes(x=C103, y=C101, col=phase))+
      geom_point()
#+end_src

#+results:
[[file:r/file74.png]]

Melt can also be used on lists

#+begin_src R :results output
  variablesToKeep = c(
      "image_number",
      "cell_id",
      "C103",
      "C104",
      "C107",
      "C108",
      "C115",
      "C118",
      "C106",
      "D110"
      )
      
  
  morphListFiltered2 <- lapply(morphListFiltered,
                               function(x){
                                   out <- x[,c("Dgroup", variablesToKeep)]
                                   out$phase <- NA
                                   out$phase[ out$Dgroup == "A" ] <- "G1"
                                   out$phase[ out$Dgroup == "A1" ] <- "S"
                                   out$phase[ out$Dgroup == "C" ] <- "M"
                                   out <- subset(out, !is.na(phase))
                                   subset(out, select = -Dgroup)
                               })
  
  
  morph <- melt(morphListFiltered2, id.vars = c(variablesToKeep, "phase"))
  head(morph)
#+end_src

#+results:
#+begin_example

  image_number cell_id     C103     C104     C107     C108     C115       C118
1            1       0 45.60702 35.60899 -1.00000 -1.00000 1.280773 -1.0000000
2            1       1 58.24088 42.72002 -1.00000 -1.00000 1.363316 -1.0000000
3            1       2 47.38143 35.35534 -1.00000 -1.00000 1.340149 -1.0000000
4            1       3 38.58756 28.30194 -1.00000 -1.00000 1.363424 -1.0000000
5            1       4 38.94868 32.55764 25.49510 21.94718 1.196299  0.4355597
6            1       5 46.17359 30.14963 34.36568 27.98131 1.531481  0.6779514
       C106     D110 phase       L1
1 -1.000000 -1.00000    G1 2a1_HAHD
2 -1.000000 -1.00000    G1 2a1_HAHD
3 -1.000000 -1.00000    G1 2a1_HAHD
4 -1.000000 -1.00000    G1 2a1_HAHD
5 67.437835 17.80449     S 2a1_HAHD
6  3.396145 11.04536     S 2a1_HAHD
#+end_example


#+begin_src R :results output
  morph.m <- melt(morphListFiltered2, id.vars = c("image_number", "cell_id", "phase"))
  head(morph.m)
#+end_src

#+results:
: 
:   image_number cell_id phase variable    value       L1
: 1            1       0    G1     C103 45.60702 2a1_HAHD
: 2            1       1    G1     C103 58.24088 2a1_HAHD
: 3            1       2    G1     C103 47.38143 2a1_HAHD
: 4            1       3    G1     C103 38.58756 2a1_HAHD
: 5            1       4     S     C103 38.94868 2a1_HAHD
: 6            1       5     S     C103 46.17359 2a1_HAHD

Now we've moved from data on a disk in sundry locations to a
convenient pair of data.frames for plotting just about anything. For
example, with a little extra work, we can compare the effect of media on the different
morphological measurements by strain

#+begin_src R :results silent
  morph$media <- sapply( strsplit(morph$L1, "_"), "[", 2)
  morph$strain <- sapply( strsplit(morph$L1, "_"), "[", 1)
  
  morph$ammonium <- sapply( strsplit(morph$media, ""), "[", 1)
  morph$dextrose <- sapply( strsplit(morph$media, ""), "[", 3)
  
  morph$ammonium <- factor(morph$ammonium,
                           levels = c("L", "H"),
                           labels = c("50uM ammonium", "5000uM ammonium"))
  
  morph$dextrose <- factor(morph$dextrose,
                           levels = c("H", "L"),
                           labels = c("2% dextrose", "0.5% dextrose"))
#+end_src


#+begin_src R :results graphics output :file r/GxE.png
  ggplot(morph, aes(x=strain, y=C103*C104, group = media, col = media))+
      stat_summary( fun.data = "mean_cl_boot", geom = "pointrange")+
      stat_summary( fun.y = "mean", geom = "line")+
      facet_grid(ammonium~dextrose)+
      theme_bw()+
      ylab("Rectangular approximation of cell size (pixels)")
#+end_src

#+results:
[[file:r/GxE.png]]


* Casting data

The other half of the reshape package is the 'cast' function. Whereas
melt moves from the wide to the long form of data, cast does the
reverse. Cast requires two arguments. The first is the data that you
want to work with. The second is a formula that tells the function how
to cast the data. The idea is that the data is rewritten into an
array. The axes of the array have various variables assigned to
them. Variables on the same axis are separated by '+' signs, and
variables on different axes are separated by '~' signs. You can have
as many axes as you want. The variables on the first axis are the
rows, the second axis are the columns, the third axis is something
like 'depth', the fourth axis is 'hyperdepth' and so on.

In the formula below we will recast our melted data back into
something like we found it in:

#+begin_src R :results output
  head(cast(morph.m, image_number + cell_id + phase + L1 ~ variable))
#+end_src

#+results:
#+begin_example
  image_number cell_id phase       L1     C103     C104     C107 C108     C115
1            1       0    G1 2a1_HAHD 45.60702 35.60899 -1.00000   -1 1.280773
2            1       0    G1 2a1_HALD 32.28002 29.12044 -1.00000   -1 1.108501
3            1       0    G1 2b1_LAHD 44.29447 30.88689 -1.00000   -1 1.434086
4            1       0     S 2b1_HAHD 54.23099 41.23106 12.04159   -1 1.315295
5            1       1    G1 2a1_HAHD 58.24088 42.72002 -1.00000   -1 1.363316
6            1       1    G1 2b1_HAHD 63.15853 50.15974 -1.00000   -1 1.259148
         C118     C106     D110
1 -1.00000000 -1.00000 -1.00000
2 -1.00000000 -1.00000 -1.00000
3 -1.00000000 -1.00000 -1.00000
4  0.06794521 27.54605 17.46425
5 -1.00000000 -1.00000 -1.00000
6 -1.00000000 -1.00000 -1.00000
#+end_example

The only difference being that there is a column corresponding to L1
rather than a list. This can be remedied by using the '|' symbol. I'll
print out the first two axes so you can see what's going on:

#+begin_src R :results output
  str(cast(morph.m, image_number + cell_id + phase ~ variable | L1)[1:2])
#+end_src

#+results:
#+begin_example
List of 2
 $ 2a1_HAHD:List of 11
 $ image_number: int [1:103] 1 1 1 1 1 1 2 2 2 2 ...
 $ cell_id     : int [1:103] 0 1 2 3 4 5 7 8 9 10 ...
 $ phase       : chr [1:103] "G1" "G1" "G1" "G1" ...
 $ C103        : num [1:103] 45.6 58.2 47.4 38.6 38.9 ...
 $ C104        : num [1:103] 35.6 42.7 35.4 28.3 32.6 ...
 $ C107        : num [1:103] -1 -1 -1 -1 25.5 ...
 $ C108        : num [1:103] -1 -1 -1 -1 21.9 ...
 $ C115        : num [1:103] 1.28 1.36 1.34 1.36 1.2 ...
 $ C118        : num [1:103] -1 -1 -1 -1 0.436 ...
 $ C106        : num [1:103] -1 -1 -1 -1 67.4 ...
 $ D110        : num [1:103] -1 -1 -1 -1 17.8 ...
 - attr(*, "row.names")= int [1:103] 1 2 3 4 5 6 7 8 9 10 ...
 - attr(*, "idvars")= chr [1:3] "image_number" "cell_id" "phase"
 - attr(*, "rdimnames")=List of 2
  ..$ :'data.frame':	103 obs. of  3 variables:
  .. ..$ image_number: int [1:103] 1 1 1 1 1 1 2 2 2 2 ...
  .. ..$ cell_id     : int [1:103] 0 1 2 3 4 5 7 8 9 10 ...
  .. ..$ phase       : chr [1:103] "G1" "G1" "G1" "G1" ...
  ..$ :'data.frame':	8 obs. of  1 variable:
  .. ..$ variable: Factor w/ 8 levels "C103","C104",..: 1 2 3 4 5 6 7 8
 $ 2a1_HALD:List of 11
 $ image_number: int [1:95] 1 1 1 1 1 2 2 2 2 2 ...
 $ cell_id     : int [1:95] 0 2 4 5 6 7 9 10 11 12 ...
 $ phase       : chr [1:95] "G1" "S" "G1" "S" ...
 $ C103        : num [1:95] 32.3 45.7 44.8 38.9 32.2 ...
 $ C104        : num [1:95] 29.1 41.2 34.5 33.1 30 ...
 $ C107        : num [1:95] -1 23.3 -1 21.6 -1 ...
 $ C108        : num [1:95] -1 22.6 -1 20.8 -1 ...
 $ C115        : num [1:95] 1.11 1.11 1.3 1.18 1.07 ...
 $ C118        : num [1:95] -1 0.281 -1 0.351 -1 ...
 $ C106        : num [1:95] -1 41.34 -1 4.49 -1 ...
 $ D110        : num [1:95] -1 15.3 -1 16.3 -1 ...
 - attr(*, "row.names")= int [1:95] 1 2 3 4 5 6 7 8 9 10 ...
 - attr(*, "idvars")= chr [1:3] "image_number" "cell_id" "phase"
 - attr(*, "rdimnames")=List of 2
  ..$ :'data.frame':	95 obs. of  3 variables:
  .. ..$ image_number: int [1:95] 1 1 1 1 1 2 2 2 2 2 ...
  .. ..$ cell_id     : int [1:95] 0 2 4 5 6 7 9 10 11 12 ...
  .. ..$ phase       : chr [1:95] "G1" "S" "G1" "S" ...
  ..$ :'data.frame':	8 obs. of  1 variable:
  .. ..$ variable: Factor w/ 8 levels "C103","C104",..: 1 2 3 4 5 6 7 8
 - attr(*, "dim")= int 2
 - attr(*, "dimnames")=List of 1
  ..$ : chr [1:2] "2a1_HAHD" "2a1_HALD"
#+end_example

If you assign a variable to a different axis, reshape will make new
columns corresponding to the different combinations of the variables:

#+begin_src R :results output
  head(cast(morph.m, image_number + cell_id + L1 ~ variable + phase))
#+end_src

#+results:
#+begin_example
  image_number cell_id       L1  C103_G1 C103_M   C103_S  C104_G1 C104_M
1            1       0 2a1_HAHD 45.60702     NA       NA 35.60899     NA
2            1       0 2a1_HALD 32.28002     NA       NA 29.12044     NA
3            1       0 2b1_HAHD       NA     NA 54.23099       NA     NA
4            1       0 2b1_LAHD 44.29447     NA       NA 30.88689     NA
5            1       1 2a1_HAHD 58.24088     NA       NA 42.72002     NA
6            1       1 2b1_HAHD 63.15853     NA       NA 50.15974     NA
    C104_S C107_G1 C107_M   C107_S C108_G1 C108_M C108_S  C115_G1 C115_M
1       NA      -1     NA       NA      -1     NA     NA 1.280773     NA
2       NA      -1     NA       NA      -1     NA     NA 1.108501     NA
3 41.23106      NA     NA 12.04159      NA     NA     -1       NA     NA
4       NA      -1     NA       NA      -1     NA     NA 1.434086     NA
5       NA      -1     NA       NA      -1     NA     NA 1.363316     NA
6       NA      -1     NA       NA      -1     NA     NA 1.259148     NA
    C115_S C118_G1 C118_M     C118_S C106_G1 C106_M   C106_S D110_G1 D110_M
1       NA      -1     NA         NA      -1     NA       NA      -1     NA
2       NA      -1     NA         NA      -1     NA       NA      -1     NA
3 1.315295      NA     NA 0.06794521      NA     NA 27.54605      NA     NA
4       NA      -1     NA         NA      -1     NA       NA      -1     NA
5       NA      -1     NA         NA      -1     NA       NA      -1     NA
6       NA      -1     NA         NA      -1     NA       NA      -1     NA
    D110_S
1       NA
2       NA
3 17.46425
4       NA
5       NA
6       NA
#+end_example

It's all very nice to be able to rewrite your data in lots of
different ways, but the real power of cast comes from its ability to
aggregate lots of different variables. Let's say we dropped out some
of the orignal variables on the first axis:

#+begin_src R :results output
  head(cast(morph.m, phase + L1 ~ variable))
#+end_src

#+results:
: Aggregation requires fun.aggregate: length used as default
:   phase       L1 C103 C104 C107 C108 C115 C118 C106 D110
: 1    G1 2a1_HAHD   61   61   61   61   61   61   61   61
: 2    G1 2a1_HALD   70   70   70   70   70   70   70   70
: 3    G1 2a1_LAHD   56   56   56   56   56   56   56   56
: 4    G1 2a1_LALD   45   45   45   45   45   45   45   45
: 5    G1 2b1_HAHD   32   32   32   32   32   32   32   32
: 6    G1 2b1_HALD   48   48   48   48   48   48   48   48

Cast warns us that there's not a unique combination. This makes sense:
there's lots of different data points that 1) measure C103, 2) are in
phase G1, and 3) belong to experiment '2a1_HAHD'. In fact, there are
61 of them. We can see this by plotting exactly this in ggplot:

#+begin_src R :results output
  ggplot(morph.m, aes(x = L1, y = value, col = phase))+
      geom_point()+facet_wrap(~variable, scale="free")
#+end_src

As a result, if you're not interested in the number of observations
that you have for a particular class of data, you need to supply a
function for cast to aggregate the data with. The argument that this
is specified under is called 'fun.aggregate'. In this case, we'll use
the mean:

#+begin_src R :results output
  morph.m$media <- sapply( strsplit(morph.m$L1, "_"), "[", 2)
  morph.m$strain <- sapply( strsplit(morph.m$L1, "_"), "[", 1)
  head(cast(morph.m, phase + L1 ~ variable, fun.aggregate = "mean"))
#+end_src

#+results:
:   phase       L1     C103     C104 C107 C108     C115 C118 C106 D110
: 1    G1 2a1_HAHD 44.42133 33.63121   -1   -1 1.322337   -1   -1   -1
: 2    G1 2a1_HALD 42.47919 33.38616   -1   -1 1.267637   -1   -1   -1
: 3    G1 2a1_LAHD 39.48546 32.13472   -1   -1 1.230856   -1   -1   -1
: 4    G1 2a1_LALD 38.65069 32.73564   -1   -1 1.184766   -1   -1   -1
: 5    G1 2b1_HAHD 50.80645 40.48347   -1   -1 1.262813   -1   -1   -1
: 6    G1 2b1_HALD 42.90138 35.51088   -1   -1 1.212462   -1   -1   -1

This isn't really the most useful summary. It might be better to write
something more like this:

#+begin_src R :results output
  cast(morph.m, strain + phase ~ media | variable, fun.aggregate = "mean")[1:3]
#+end_src




* plyr the split, apply, combine paradigm
** ddply
** dlply
** ldply
** ddply for reading in complex data
* Melting your data into a form usable by ggplot
* Casting your data to plot summary statistics
* Casting your data for subsequent filtering
* How to deal with obnoxious data
- Example using Tecan output and scan

